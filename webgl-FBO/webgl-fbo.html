<html>
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>Triangle</title> <!--标题-->
	<script type="text/javascript" src="js/Matrix.js"></script>
	<script type="text/javascript" src="js/MatrixState.js"></script>	
	<script type="text/javascript" src="js/GLUtil.js"></script>
	<script type="text/javascript" src="js/Triangle.js"></script>
	<script type="text/javascript" src="js/LoadShaderUtil.js"></script>
	<script type="text/javascript" src="./webgl-utils.js"></script>
	<script>
		Locations =  {
			INPOS: 'inPos',
			MOUSE: 'iMouse',
			RESOLUTION: 'iResolution',
			TIME: 'iTime',
		}
		vs = `#version 300 es
		in vec2 inPos;

		void main() 
		{
			gl_Position = vec4(inPos, 0.0, 1.0);
		}
		`
		fs = `#version 300 es
		precision mediump float;

		uniform vec2    iResolution;
		uniform float   iTime;
		uniform float   iChannelTime[4];
		uniform vec2    iMouse;
		uniform vec4    iDate;
		uniform float   iSampleRate;
		uniform vec3    iChannelResolution[4];
		uniform int     iFrame;
		uniform float   iTimeDelta;
		uniform float   iFrameRate;

		in  vec2 fragCoord;
		out vec4 fragColor;

		void mainImage(out vec4 fragColor, in vec2 fragCoord)
		{
			vec2 st = fragCoord.xy / iResolution.xy / (100.0*iTime);
			fragColor = vec4(st, 0.0, 1.0);
		}
		void main() 
		{
			vec4 color = vec4(0.0,0.0,0.0,1.0);
			mainImage(color, gl_FragCoord.xy);
			if(fragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);
			if(fragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);
			if(fragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);
			if(fragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);
			if(fragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);
			fragColor = vec4(color.xyz,1.0);
		}
		`

		fs2 = `#version 300 es
		precision mediump float;

		uniform vec2    iResolution;
		uniform float   iTime;
		uniform float   iChannelTime[4];
		uniform vec2    iMouse;
		uniform vec4    iDate;
		uniform float   iSampleRate;
		uniform vec3    iChannelResolution[4];
		uniform int     iFrame;
		uniform float   iTimeDelta;
		uniform float   iFrameRate;

		in  vec2 fragCoord;
		out vec4 fragColor;

		void mainImage(out vec4 fragColor, in vec2 fragCoord)
		{
			vec2 st = fragCoord.xy / (100.0*iTime);
			fragColor = vec4(st, 0.0, 1.0);
		}
		void main() 
		{
			vec4 color = vec4(0.0,0.0,0.0,1.0);
			mainImage(color, gl_FragCoord.xy);
			if(fragColor.w<0.0) color=vec4(1.0,0.0,0.0,1.0);
			if(fragColor.x<0.0) color=vec4(1.0,0.0,0.0,1.0);
			if(fragColor.y<0.0) color=vec4(0.0,1.0,0.0,1.0);
			if(fragColor.z<0.0) color=vec4(0.0,0.0,1.0,1.0);
			if(fragColor.w<0.0) color=vec4(1.0,1.0,0.0,1.0);
			fragColor = vec4(color.xyz,1.0);
		}
		`

		const POS_DATA = [-1, -1, 1, -1, 1, 1, -1, 1];
		const INX_DATA = [0, 1, 2, 0, 2, 3];
		var canvas
		var time = 1 / 1000.0
		//GLES上下文
		var	gl
		var program
	    //变换矩阵管理类对象
	    var ms=new MatrixState();
	    //要绘制的3D物体
	    var ooTri, ooTri2;
		var vertexData1 = [7,-5,0,
					  -7,-5,0.0,
					  -7,5,0.0,
					//   7, 5, 0,
					//   7, -5, 0,
					//   -7, 7, 0
					]/*[3.0,0.0,0.0,
					  0.0,0.0,0.0,
					  0.0,4.0,0.0];*/
		var vertexData2 = [3.0,0.0,0.0,
					  0.0,0.0,0.0,
					  0.0,4.0,0.0,
					  -3, 4, 0,
					  0, 0, 0,
					  0, 4, 0
					];
		//着色器程序列表，集中管理
		var shaderProgArray=new Array();
      //  var fb, rb, texture;
        var framebuffer;
        var texture;
        //初始化的方法
		function init() {
			canvas = document.getElementById('bncanvas');
			gl = initWebGLCanvas('bncanvas')
			console.log(gl)
		}

		function createShader(gl, type, source) {
			let shader = gl.createShader(type);
			gl.shaderSource(shader, source);
			gl.compileShader(shader);
			let success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
			if (success) {
				return shader;
			}

			console.log(gl.getShaderInfoLog(shader));
			gl.deleteShader(shader);
		}

		function createProgram(gl, vertexShader, fragmentShader) {
			let program = gl.createProgram();
			gl.attachShader(program, vertexShader);
			gl.attachShader(program, fragmentShader);
			gl.linkProgram(program);
			let success = gl.getProgramParameter(program, gl.LINK_STATUS);
			if (success) {
				return program;
			}

			console.log(gl.getProgramInfoLog(program));
			gl.deleteProgram(program);
		}

	    function start()
	    {    		        
			init()
	        if (!gl) //若获取GL上下文失败
			{
				alert("创建GLES上下文失败!");//显示错误提示信息
				return
			}   
			// create GLSL shaders, upload the GLSL source, compile the shaders
			var vertexShader = createShader(gl, gl.VERTEX_SHADER, vs);
			var fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fs);
			console.log(vertexShader, fragmentShader)

			// Link the two shaders into a program
			program = createProgram(gl, vertexShader, fragmentShader);

			var vertexShader2 = createShader(gl, gl.VERTEX_SHADER, vs);
			var fragmentShader2 = createShader(gl, gl.FRAGMENT_SHADER, fs2);
			console.log(vertexShader2, fragmentShader2)

			// Link the two shaders into a program
			program2 = createProgram(gl, vertexShader2, fragmentShader2);
			

			const positionLocation = gl.getAttribLocation(
				program,
				Locations.INPOS,
			);
			const positionLocation2 = gl.getAttribLocation(
				program2,
				Locations.INPOS,
			);
	        //获取GL上下文
	        // gl = initWebGLCanvas("bncanvas");
			
			// if (version === OpenGlEsVersion.ES2) {
			// 	this.gl = this.canvas.getContext('webgl');
			// } else {
				// gl = canvas.getContext('webgl2');
			// }
			gl.useProgram(program);
			bufferPos = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, bufferPos);
			gl.bufferData(
				gl.ARRAY_BUFFER,
				new Float32Array(POS_DATA),
				gl.STATIC_DRAW,
			);
			bufferInx = gl.createBuffer();
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInx);
			gl.bufferData(
				gl.ELEMENT_ARRAY_BUFFER,
				new Uint16Array(INX_DATA),
				gl.STATIC_DRAW,
			);
			gl.enableVertexAttribArray(positionLocation);
			gl.vertexAttribPointer(
				positionLocation,
				2,
				gl.FLOAT,
				false,
				0,
				0,
			);
			gl.enableVertexAttribArray(positionLocation2);
			gl.vertexAttribPointer(
				positionLocation2,
				2,
				gl.FLOAT,
				false,
				0,
				0,
			);

			gl.enable(gl.DEPTH_TEST);
			gl.clearColor(0.0, 0.0, 0.0, 1.0);
			initFramebufferObject(gl)

			
			render()
	    }
		function render() {
			// 在帧缓冲区的颜色关联对象即纹理对象中绘制立方体，纹理使用图片
			gl.useProgram(program2)
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);// 绑定帧缓冲区对象后绘制就会在绑定帧缓冲区中进行绘制
			gl.viewport(0, 0, canvas.width, canvas.height);
            // gl.clearColor(0.2, 0.2, 0.4, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
			gl.uniform2f(
				gl.getUniformLocation(
					program2,
					Locations.RESOLUTION,
				),
				canvas.width,
				canvas.height,
			);
			gl.uniform1f(
				gl.getUniformLocation(
					program2,
					Locations.TIME,
				),
				time//1 / 1000.0,
			);
			time += 0.01
			// console.log(gl.getUniformLocation(
			// 		program2,
			// 		Locations.TIME,
			// 	))

			gl.drawElements(
				gl.TRIANGLES,
				INX_DATA.length,
				gl.UNSIGNED_SHORT,
				0,
			);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
       		gl.bindTexture(gl.TEXTURE_2D, null);

			///////////////////////--------------主图形
			gl.useProgram(program)
			// vertexTexCoorBuffer=gl.createBuffer();
			// //将顶点纹理坐标数据送入缓冲
			// gl.bindBuffer(gl.ARRAY_BUFFER,vertexTexCoorBuffer);
			// gl.bufferData(gl.ARRAY_BUFFER,new Float32Array(INX_DATA),gl.STATIC_DRAW);
			// gl.bindBuffer(gl.ARRAY_BUFFER, vertexTexCoorBuffer);

			gl.bindFramebuffer(gl.FRAMEBUFFER, null);// 接触绑定之后，会在默认的颜色缓冲区中绘制
            gl.bindTexture(gl.TEXTURE_2D, texture);
			gl.viewport(0, 0, canvas.width, canvas.height);
			gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

			gl.uniform2f(
				gl.getUniformLocation(
					program,
					Locations.RESOLUTION,
				),
				canvas.width,
				canvas.height,
			);
			gl.uniform1f(
				gl.getUniformLocation(
					program,
					Locations.TIME,
				),
				1/1000.0,
			);
			// console.log(time)
			// time += 0.00001

			gl.drawElements(
				gl.TRIANGLES,
				INX_DATA.length,
				gl.UNSIGNED_SHORT,
				0,
			);
			gl.bindFramebuffer(gl.FRAMEBUFFER, null);
       		gl.bindTexture(gl.TEXTURE_2D, null);
			requestAnimationFrame(render);
		}
	    //绘制一帧画面的方法
	    function drawFrame()
	    {	  
			if(!ooTri){
				alert("加载未完成！");//提示信息
				return;
			}
            // 在帧缓冲区的颜色关联对象即纹理对象中绘制立方体，纹理使用图片
            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);// 绑定帧缓冲区对象后绘制就会在绑定帧缓冲区中进行绘制

            gl.viewport(0, 0, 280, 280);
            gl.clearColor(0.2, 0.2, 0.4, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            //保护现场
            ms.pushMatrix();
            //执行旋转
            ms.rotate(currentAngle,0,0,1);

            ooTri2.drawSelf(ms, false);
            //恢复现场
            ms.popMatrix();

			//----------------------------------------------------------------------------------------------------------
            // 在canvas上绘制矩形，纹理使用上一步在纹理对象中绘制的图像
            gl.bindFramebuffer(gl.FRAMEBUFFER, null);// 接触绑定之后，会在默认的颜色缓冲区中绘制
            gl.bindTexture(gl.TEXTURE_2D, texture);

            gl.viewport(0, 0, 800, 800);

            //背景颜色_黑色
            gl.clearColor(0.0, 0.0, 0.0, 1.0);

            //清除着色缓冲与深度缓冲
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);


	        //保护现场
	        // ms.pushMatrix(); 
	        // //执行旋转
			// ms.rotate(currentAngle,0,1,0);
			// //绘制物体
			ooTri.drawSelf(ms, true);
			// //恢复现场
			// ms.popMatrix();
			//修改旋转角度
	        currentAngle += incAngle;
	        if (currentAngle > 360)//保证角度范围不超过360
	            currentAngle -= 360; 			
	    }
        function initFramebufferObject(gl) {
             framebuffer = gl.createFramebuffer();

            // 新建纹理对象作为帧缓冲区的颜色缓冲区对象
             texture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, canvas.width, canvas.height, 0, gl.RGB, gl.UNSIGNED_BYTE, null);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

            // 新建渲染缓冲区对象作为帧缓冲区的深度缓冲区对象
            var depthBuffer = gl.createRenderbuffer();
            gl.bindRenderbuffer(gl.RENDERBUFFER, depthBuffer);
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, canvas.width, canvas.height);

            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, depthBuffer);

            // 检测帧缓冲区对象的配置状态是否成功
            var e = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
            if (gl.FRAMEBUFFER_COMPLETE !== e) {
                console.log('Frame buffer object is incomplete: ' + e.toString());
                return;
            }

            gl.bindFramebuffer(gl.FRAMEBUFFER, null);
            gl.bindTexture(gl.TEXTURE_2D, null);
            gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
		// start()
	</script>
</head>

<body onload="start();">
	<canvas height="800" width="800" id="bncanvas">
	    若看到这个文字，说明浏览器不支持WebGL!
	</canvas>
	<canvas height="800" width="800" id="canvas">
	</canvas>
	<div id="sdf"></div>
</body>
</html>